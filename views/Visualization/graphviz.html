{{extend 'content.html'}}

<style>
	#Controls		{
				border:			1px solid black;
				position:		absolute;
				top:			-10%;
				right:			1%;
				z-index:		+5;
				background-color:	white;
				opacity:		1;
				}

	#network		{
				border:			none;
				position:		absolute;
				top:			15%;
				left:			1%;
				width:			98%;
				height:			83%;
				}

</style>

<script>
	function deepcopy(obj) {
		var copy = {};
		for (key in obj)
			copy[key] = obj[key];
		return copy;
		}

	// settings
	green = '#10d010';
	red = '#d01010';
	yellow = '#f4fd01';
	black = '#000000';
	blue = '#7474cf';
	active = green;
	inactive = 'white';
	cyclic_attraktor = '#f9f883';

	// input, provided by the server
	Nodes = [ {{=XML(Nodes)}} ];
	update_rules = { {{=XML(updateRules)}} };

	// initialize, prepare for simulation
	SimulationRunning = false;
	reset_Statespace = {};
	Nodes_getting_updated = {};
	for (n in Nodes) {
		reset_Statespace[Nodes[n]] = true;
		Nodes_getting_updated[Nodes[n]] = true;
		}
	Statespace = deepcopy(reset_Statespace);

	function SVGonClick(event) {
		node = event.srcElement.id;
		if (event.ctrlKey)
			Nodes_getting_updated[node] = ! Nodes_getting_updated[node];
		else
			Statespace[node] = ! Statespace[node];
		RefreshGraph();
		};

	function installSVGonClickListeners() {
		for (n in Nodes)
			svg.getElementById(Nodes[n]).onclick = SVGonClick;
		}

	function PaintBoxes() {
		for (n in Nodes) {
			if ( Statespace[Nodes[n]] )
				svg.getElementById(Nodes[n]).style.fill = active;
			else
				svg.getElementById(Nodes[n]).style.fill = inactive;

			if ( Nodes_getting_updated[Nodes[n]] )
				svg.getElementById(Nodes[n]).style['stroke-dasharray'] = 'none';
			else
				svg.getElementById(Nodes[n]).style['stroke-dasharray'] = '3,3';
			}
		}

	function Reset() {
		document.getElementById('Progress').innerHTML = 'Resetting ...';
		Statespace = reset_Statespace;
		PaintBoxes();
		document.getElementById('Progress').innerHTML = 'Reset.';
		}

	function Iterate() {
		SimulationRunning = true;

		// messages
		e = document.getElementById('Progress');
		if ( e.innerHTML.length > 30 || e.innerHTML.substr(0,9) != 'Iterating' )
			e.innerHTML = 'Iterating ...'
		else	e.innerHTML = e.innerHTML+'.';
		steps = document.getElementById('Steps');
		steps.innerHTML = parseInt(steps.innerHTML)+1;

		// calculation
		updates_made = false;
		var updated_Statespace = deepcopy(Statespace);
		for (node in update_rules)	// for key in hash
			if ( Nodes_getting_updated[node] ) {
				updated_Statespace[node] = eval( update_rules[node] );
				if ( updated_Statespace[node] != Statespace[node] )
					updates_made = true;
				}

		// steady state ?
		if ( updates_made ) {	// network updated -> steady state not reached
			Statespace = updated_Statespace;
			PaintBoxes();
			try { delay=parseInt(document.getElementById('Delay').value);	}
			catch(err) { delay=120;	}
			window.setTimeout('Iterate();', delay);
			}
		else 	{	// no changes -> steady state
			PaintBoxes();
			e.innerHTML = 'Boolean network reached steady state.';
			SimulationRunning = false;
			}
		}

	function RefreshGraph() {
		document.getElementById('Progress').innerHTML = 'Refreshing graph ...';
		PaintBoxes();
		// start Simulation, if it's not running already
		if ( ! SimulationRunning ) {
			document.getElementById('Steps').innerHTML = 0;
			Iterate();
			}
		document.getElementById('Progress').innerHTML = 'Graph refreshed.';
		}

	function selectScenario(event) {
		try	{
			delay=parseInt(document.getElementById('Delay').value);
			}
		catch(err) {
			delay=120;
			}
		window.setTimeout(event.srcElement.options[event.srcElement.selectedIndex].value, delay);
		}

{{ = XML(ScenarioFunctions) }}

	function refreshSVG() {
		document.network.style.visibility = "hidden";
		document.network.style.visibility = "visible";
		}

	function bringtoFront(element) {
		cache = element;
		alert(element);
		graph.removeChild(svg.getElementById(element));
		graph.appendChild(svg.getElementById(cache));
		}

	function colorifyAttractorEdge(node1, node2) {
		path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		path.setAttributeNS(null, 'style', 'fill:none; stroke:#f9f883; stroke-width:80; stroke-linecap:round;');
		x1 = svg.getElementById(node1).cx.baseVal.value;
		y1 = svg.getElementById(node1).cy.baseVal.value;
		x2 = svg.getElementById(node2).cx.baseVal.value;
		y2 = svg.getElementById(node2).cy.baseVal.value;
		path.setAttributeNS(null, 'd', 'M '+x1+','+y1+' '+x2+','+y2);
		graph.appendChild(path);
//		bringtoFront(node1);
//		bringtoFront(node2);
		}

	function FindAttractors() {
		// query the server via XmlHttpRequest ... BooleanNet python simulation ...

//		polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
//		polygon.setAttributeNS(null, 'fill', cyclic_attraktor);
//		polygon.setAttributeNS(null, 'points', '-1,1 -1,-100 100,-100 100,1 -1,1');

		colorifyAttractorEdge('Ras2', 'cAMP');
//		colorifyAttractorEdge('cAMP', 'PKA');
//		colorifyAttractorEdge('PKA', 'Ras2');
		refreshSVG();
		}

</script>

<div id=Controls>
	&nbsp;Delay between iteration steps: <input id=Delay type=text value='100' style='width:50px; text-align:right;' /> ms
	<br/>

	<form name=main action="{{=URL(r=request, c='Import', f='BooleanNet')}}" method=POST enctype="multipart/form-data" style="display:inline;">
		&nbsp;Available networks:
		<select name=Model>
			<option selected></option>
{{for model in AvailableNetworks:}}			<option value="{{=model}}">{{=model}}</option>{{pass}}
		</select>
		<input type=hidden name=Layouter value=graphviz />
		<input type=submit value="Load network" />
		<br/>
	</form>

	&nbsp;Available scenarios:
	<select name=Scenario onChange="selectScenario(event);">
		<option value="null;" selected></option>
{{ = XML(ScenarioOptions) }}
	</select>
	<input type=button value="(Plot)" />
	<br/>

	<input type=button value="Reset state space" onClick="Reset();" />
	<br/>
	<input type=button value="Find attractors" onClick="FindAttractors();" />
	<br/>

	&nbsp;<label id='Progress' style='color:green; font-weight:bold;'></label>
	<label id='Steps' style='color:blue; font-weight:bold; float:right;'>0</label>
</div>

Click the nodes to change their respective state.
Press Ctrl when clicking to fix or unfix a node.
State-of-the-art browser required (Chrome or Firefox; not Internet Explorer).
SVG support required. JavaScript needs to be enabled.

<object type="image/svg+xml" name=network id=network data="{{ = session.graphviz_image }}" onLoad="svg=this.contentDocument; graph=svg.getElementById('graph1'); installSVGonClickListeners(); Reset(); Iterate();" ></object>
 
<script>
	function AutoLoad() {
		if ( document.getElementById('network').contentDocument == undefined )
			document.main.submit();
		}
	window.setTimeout('AutoLoad();', 100);
</script>

